//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package xmlgroup

import "time"

// AccessPolicy - An Access policy
type AccessPolicy struct {
	// REQUIRED; the date-time the policy expires
	Expiry *time.Time `xml:"Expiry"`

	// REQUIRED; the permissions for the acl policy
	Permission *string `xml:"Permission"`

	// REQUIRED; the date-time the policy is active
	Start *time.Time `xml:"Start"`
}

func (a *AccessPolicy) GetExpiry() (rv *time.Time) {
	if a != nil {
		return a.Expiry
	}
	return
}

func (a *AccessPolicy) GetPermission() (rv string) {
	if a != nil && a.Permission != nil {
		return *a.Permission
	}
	return
}

func (a *AccessPolicy) GetStart() (rv *time.Time) {
	if a != nil {
		return a.Start
	}
	return
}

// AppleBarrel - A barrel of apples.
type AppleBarrel struct {
	BadApples  []*string `xml:"BadApples>Apple"`
	GoodApples []*string `xml:"GoodApples>Apple"`
}

func (a *AppleBarrel) GetBadApples() (rv []*string) {
	if a != nil {
		return a.BadApples
	}
	return
}

func (a *AppleBarrel) GetGoodApples() (rv []*string) {
	if a != nil {
		return a.GoodApples
	}
	return
}

// Banana - A banana.
type Banana struct {
	// The time at which you should reconsider eating this banana
	Expiration *time.Time `xml:"expiration"`
	Flavor     *string    `xml:"flavor"`
	Name       *string    `xml:"name"`
}

func (b *Banana) GetExpiration() (rv *time.Time) {
	if b != nil {
		return b.Expiration
	}
	return
}

func (b *Banana) GetFlavor() (rv string) {
	if b != nil && b.Flavor != nil {
		return *b.Flavor
	}
	return
}

func (b *Banana) GetName() (rv string) {
	if b != nil && b.Name != nil {
		return *b.Name
	}
	return
}

// Blob - An Azure Storage blob
type Blob struct {
	// REQUIRED
	Deleted *bool `xml:"Deleted"`

	// REQUIRED
	Name *string `xml:"Name"`

	// REQUIRED; Properties of a blob
	Properties *BlobProperties `xml:"Properties"`

	// REQUIRED
	Snapshot *string `xml:"Snapshot"`

	// Dictionary of
	Metadata map[string]*string `xml:"Metadata"`
}

func (b *Blob) GetDeleted() (rv bool) {
	if b != nil && b.Deleted != nil {
		return *b.Deleted
	}
	return
}

func (b *Blob) GetName() (rv string) {
	if b != nil && b.Name != nil {
		return *b.Name
	}
	return
}

func (b *Blob) GetProperties() (rv *BlobProperties) {
	if b != nil {
		return b.Properties
	}
	return
}

func (b *Blob) GetSnapshot() (rv string) {
	if b != nil && b.Snapshot != nil {
		return *b.Snapshot
	}
	return
}

func (b *Blob) GetMetadata() (rv map[string]*string) {
	if b != nil {
		return b.Metadata
	}
	return
}

type BlobPrefix struct {
	// REQUIRED
	Name *string `xml:"Name"`
}

func (b *BlobPrefix) GetName() (rv string) {
	if b != nil && b.Name != nil {
		return *b.Name
	}
	return
}

// BlobProperties - Properties of a blob
type BlobProperties struct {
	// REQUIRED
	Etag *string `xml:"Etag"`

	// REQUIRED
	LastModified       *time.Time     `xml:"Last-Modified"`
	AccessTier         *AccessTier    `xml:"AccessTier"`
	AccessTierInferred *bool          `xml:"AccessTierInferred"`
	ArchiveStatus      *ArchiveStatus `xml:"ArchiveStatus"`
	BlobSequenceNumber *int32         `xml:"x-ms-blob-sequence-number"`
	BlobType           *BlobType      `xml:"BlobType"`
	CacheControl       *string        `xml:"Cache-Control"`
	ContentDisposition *string        `xml:"Content-Disposition"`
	ContentEncoding    *string        `xml:"Content-Encoding"`
	ContentLanguage    *string        `xml:"Content-Language"`

	// Size in bytes
	ContentLength          *int64             `xml:"Content-Length"`
	ContentMD5             *string            `xml:"Content-MD5"`
	ContentType            *string            `xml:"Content-Type"`
	CopyCompletionTime     *time.Time         `xml:"CopyCompletionTime"`
	CopyID                 *string            `xml:"CopyId"`
	CopyProgress           *string            `xml:"CopyProgress"`
	CopySource             *string            `xml:"CopySource"`
	CopyStatus             *CopyStatusType    `xml:"CopyStatus"`
	CopyStatusDescription  *string            `xml:"CopyStatusDescription"`
	DeletedTime            *time.Time         `xml:"DeletedTime"`
	DestinationSnapshot    *string            `xml:"DestinationSnapshot"`
	IncrementalCopy        *bool              `xml:"IncrementalCopy"`
	LeaseDuration          *LeaseDurationType `xml:"LeaseDuration"`
	LeaseState             *LeaseStateType    `xml:"LeaseState"`
	LeaseStatus            *LeaseStatusType   `xml:"LeaseStatus"`
	RemainingRetentionDays *int32             `xml:"RemainingRetentionDays"`
	ServerEncrypted        *bool              `xml:"ServerEncrypted"`
}

func (b *BlobProperties) GetEtag() (rv string) {
	if b != nil && b.Etag != nil {
		return *b.Etag
	}
	return
}

func (b *BlobProperties) GetLastModified() (rv *time.Time) {
	if b != nil {
		return b.LastModified
	}
	return
}

func (b *BlobProperties) GetAccessTier() (rv *AccessTier) {
	if b != nil {
		return b.AccessTier
	}
	return
}

func (b *BlobProperties) GetAccessTierInferred() (rv bool) {
	if b != nil && b.AccessTierInferred != nil {
		return *b.AccessTierInferred
	}
	return
}

func (b *BlobProperties) GetArchiveStatus() (rv *ArchiveStatus) {
	if b != nil {
		return b.ArchiveStatus
	}
	return
}

func (b *BlobProperties) GetBlobSequenceNumber() (rv int32) {
	if b != nil && b.BlobSequenceNumber != nil {
		return *b.BlobSequenceNumber
	}
	return
}

func (b *BlobProperties) GetBlobType() (rv *BlobType) {
	if b != nil {
		return b.BlobType
	}
	return
}

func (b *BlobProperties) GetCacheControl() (rv string) {
	if b != nil && b.CacheControl != nil {
		return *b.CacheControl
	}
	return
}

func (b *BlobProperties) GetContentDisposition() (rv string) {
	if b != nil && b.ContentDisposition != nil {
		return *b.ContentDisposition
	}
	return
}

func (b *BlobProperties) GetContentEncoding() (rv string) {
	if b != nil && b.ContentEncoding != nil {
		return *b.ContentEncoding
	}
	return
}

func (b *BlobProperties) GetContentLanguage() (rv string) {
	if b != nil && b.ContentLanguage != nil {
		return *b.ContentLanguage
	}
	return
}

func (b *BlobProperties) GetContentLength() (rv int64) {
	if b != nil && b.ContentLength != nil {
		return *b.ContentLength
	}
	return
}

func (b *BlobProperties) GetContentMD5() (rv string) {
	if b != nil && b.ContentMD5 != nil {
		return *b.ContentMD5
	}
	return
}

func (b *BlobProperties) GetContentType() (rv string) {
	if b != nil && b.ContentType != nil {
		return *b.ContentType
	}
	return
}

func (b *BlobProperties) GetCopyCompletionTime() (rv *time.Time) {
	if b != nil {
		return b.CopyCompletionTime
	}
	return
}

func (b *BlobProperties) GetCopyID() (rv string) {
	if b != nil && b.CopyID != nil {
		return *b.CopyID
	}
	return
}

func (b *BlobProperties) GetCopyProgress() (rv string) {
	if b != nil && b.CopyProgress != nil {
		return *b.CopyProgress
	}
	return
}

func (b *BlobProperties) GetCopySource() (rv string) {
	if b != nil && b.CopySource != nil {
		return *b.CopySource
	}
	return
}

func (b *BlobProperties) GetCopyStatus() (rv *CopyStatusType) {
	if b != nil {
		return b.CopyStatus
	}
	return
}

func (b *BlobProperties) GetCopyStatusDescription() (rv string) {
	if b != nil && b.CopyStatusDescription != nil {
		return *b.CopyStatusDescription
	}
	return
}

func (b *BlobProperties) GetDeletedTime() (rv *time.Time) {
	if b != nil {
		return b.DeletedTime
	}
	return
}

func (b *BlobProperties) GetDestinationSnapshot() (rv string) {
	if b != nil && b.DestinationSnapshot != nil {
		return *b.DestinationSnapshot
	}
	return
}

func (b *BlobProperties) GetIncrementalCopy() (rv bool) {
	if b != nil && b.IncrementalCopy != nil {
		return *b.IncrementalCopy
	}
	return
}

func (b *BlobProperties) GetLeaseDuration() (rv *LeaseDurationType) {
	if b != nil {
		return b.LeaseDuration
	}
	return
}

func (b *BlobProperties) GetLeaseState() (rv *LeaseStateType) {
	if b != nil {
		return b.LeaseState
	}
	return
}

func (b *BlobProperties) GetLeaseStatus() (rv *LeaseStatusType) {
	if b != nil {
		return b.LeaseStatus
	}
	return
}

func (b *BlobProperties) GetRemainingRetentionDays() (rv int32) {
	if b != nil && b.RemainingRetentionDays != nil {
		return *b.RemainingRetentionDays
	}
	return
}

func (b *BlobProperties) GetServerEncrypted() (rv bool) {
	if b != nil && b.ServerEncrypted != nil {
		return *b.ServerEncrypted
	}
	return
}

type Blobs struct {
	Blob       []*Blob       `xml:"Blob"`
	BlobPrefix []*BlobPrefix `xml:"BlobPrefix"`
}

func (b *Blobs) GetBlob() (rv []*Blob) {
	if b != nil {
		return b.Blob
	}
	return
}

func (b *Blobs) GetBlobPrefix() (rv []*BlobPrefix) {
	if b != nil {
		return b.BlobPrefix
	}
	return
}

// ComplexTypeNoMeta - I am a complex type with no XML node
type ComplexTypeNoMeta struct {
	// The id of the res
	ID *string `xml:"ID"`
}

func (c *ComplexTypeNoMeta) GetID() (rv string) {
	if c != nil && c.ID != nil {
		return *c.ID
	}
	return
}

// ComplexTypeWithMeta - I am a complex type with XML node
type ComplexTypeWithMeta struct {
	// The id of the res
	ID *string `xml:"ID"`
}

func (c *ComplexTypeWithMeta) GetID() (rv string) {
	if c != nil && c.ID != nil {
		return *c.ID
	}
	return
}

// Container - An Azure Storage container
type Container struct {
	// REQUIRED
	Name *string `xml:"Name"`

	// REQUIRED; Properties of a container
	Properties *ContainerProperties `xml:"Properties"`

	// Dictionary of
	Metadata map[string]*string `xml:"Metadata"`
}

func (c *Container) GetName() (rv string) {
	if c != nil && c.Name != nil {
		return *c.Name
	}
	return
}

func (c *Container) GetProperties() (rv *ContainerProperties) {
	if c != nil {
		return c.Properties
	}
	return
}

func (c *Container) GetMetadata() (rv map[string]*string) {
	if c != nil {
		return c.Metadata
	}
	return
}

// ContainerProperties - Properties of a container
type ContainerProperties struct {
	// REQUIRED
	Etag *string `xml:"Etag"`

	// REQUIRED
	LastModified  *time.Time         `xml:"Last-Modified"`
	LeaseDuration *LeaseDurationType `xml:"LeaseDuration"`
	LeaseState    *LeaseStateType    `xml:"LeaseState"`
	LeaseStatus   *LeaseStatusType   `xml:"LeaseStatus"`
	PublicAccess  *PublicAccessType  `xml:"PublicAccess"`
}

func (c *ContainerProperties) GetEtag() (rv string) {
	if c != nil && c.Etag != nil {
		return *c.Etag
	}
	return
}

func (c *ContainerProperties) GetLastModified() (rv *time.Time) {
	if c != nil {
		return c.LastModified
	}
	return
}

func (c *ContainerProperties) GetLeaseDuration() (rv *LeaseDurationType) {
	if c != nil {
		return c.LeaseDuration
	}
	return
}

func (c *ContainerProperties) GetLeaseState() (rv *LeaseStateType) {
	if c != nil {
		return c.LeaseState
	}
	return
}

func (c *ContainerProperties) GetLeaseStatus() (rv *LeaseStatusType) {
	if c != nil {
		return c.LeaseStatus
	}
	return
}

func (c *ContainerProperties) GetPublicAccess() (rv *PublicAccessType) {
	if c != nil {
		return c.PublicAccess
	}
	return
}

// CorsRule - CORS is an HTTP feature that enables a web application running under one domain to access resources in another
// domain. Web browsers implement a security restriction known as same-origin policy that
// prevents a web page from calling APIs in a different domain; CORS provides a secure way to allow one domain (the origin
// domain) to call APIs in another domain
type CorsRule struct {
	// REQUIRED; the request headers that the origin domain may specify on the CORS request.
	AllowedHeaders *string `xml:"AllowedHeaders"`

	// REQUIRED; The methods (HTTP request verbs) that the origin domain may use for a CORS request. (comma separated)
	AllowedMethods *string `xml:"AllowedMethods"`

	// REQUIRED; The origin domains that are permitted to make a request against the storage service via CORS. The origin domain
	// is the domain from which the request originates. Note that the origin must be an exact
	// case-sensitive match with the origin that the user age sends to the service. You can also use the wildcard character '*'
	// to allow all origin domains to make requests via CORS.
	AllowedOrigins *string `xml:"AllowedOrigins"`

	// REQUIRED; The response headers that may be sent in the response to the CORS request and exposed by the browser to the request
	// issuer
	ExposedHeaders *string `xml:"ExposedHeaders"`

	// REQUIRED; The maximum amount time that a browser should cache the preflight OPTIONS request.
	MaxAgeInSeconds *int32 `xml:"MaxAgeInSeconds"`
}

func (c *CorsRule) GetAllowedHeaders() (rv string) {
	if c != nil && c.AllowedHeaders != nil {
		return *c.AllowedHeaders
	}
	return
}

func (c *CorsRule) GetAllowedMethods() (rv string) {
	if c != nil && c.AllowedMethods != nil {
		return *c.AllowedMethods
	}
	return
}

func (c *CorsRule) GetAllowedOrigins() (rv string) {
	if c != nil && c.AllowedOrigins != nil {
		return *c.AllowedOrigins
	}
	return
}

func (c *CorsRule) GetExposedHeaders() (rv string) {
	if c != nil && c.ExposedHeaders != nil {
		return *c.ExposedHeaders
	}
	return
}

func (c *CorsRule) GetMaxAgeInSeconds() (rv int32) {
	if c != nil && c.MaxAgeInSeconds != nil {
		return *c.MaxAgeInSeconds
	}
	return
}

type JSONInput struct {
	ID *int32
}

func (j *JSONInput) GetID() (rv int32) {
	if j != nil && j.ID != nil {
		return *j.ID
	}
	return
}

type JSONOutput struct {
	ID *int32
}

func (j *JSONOutput) GetID() (rv int32) {
	if j != nil && j.ID != nil {
		return *j.ID
	}
	return
}

// ListBlobsResponse - An enumeration of blobs
type ListBlobsResponse struct {
	// REQUIRED
	Blobs *Blobs `xml:"Blobs"`

	// REQUIRED
	ContainerName *string `xml:"ContainerName,attr"`

	// REQUIRED
	Delimiter *string `xml:"Delimiter"`

	// REQUIRED
	Marker *string `xml:"Marker"`

	// REQUIRED
	MaxResults *int32 `xml:"MaxResults"`

	// REQUIRED
	NextMarker *string `xml:"NextMarker"`

	// REQUIRED
	Prefix          *string `xml:"Prefix"`
	ServiceEndpoint *string `xml:"ServiceEndpoint,attr"`
}

func (l *ListBlobsResponse) GetBlobs() (rv *Blobs) {
	if l != nil {
		return l.Blobs
	}
	return
}

func (l *ListBlobsResponse) GetContainerName() (rv string) {
	if l != nil && l.ContainerName != nil {
		return *l.ContainerName
	}
	return
}

func (l *ListBlobsResponse) GetDelimiter() (rv string) {
	if l != nil && l.Delimiter != nil {
		return *l.Delimiter
	}
	return
}

func (l *ListBlobsResponse) GetMarker() (rv string) {
	if l != nil && l.Marker != nil {
		return *l.Marker
	}
	return
}

func (l *ListBlobsResponse) GetMaxResults() (rv int32) {
	if l != nil && l.MaxResults != nil {
		return *l.MaxResults
	}
	return
}

func (l *ListBlobsResponse) GetNextMarker() (rv string) {
	if l != nil && l.NextMarker != nil {
		return *l.NextMarker
	}
	return
}

func (l *ListBlobsResponse) GetPrefix() (rv string) {
	if l != nil && l.Prefix != nil {
		return *l.Prefix
	}
	return
}

func (l *ListBlobsResponse) GetServiceEndpoint() (rv string) {
	if l != nil && l.ServiceEndpoint != nil {
		return *l.ServiceEndpoint
	}
	return
}

// ListContainersResponse - An enumeration of containers
type ListContainersResponse struct {
	// REQUIRED
	MaxResults *int32 `xml:"MaxResults"`

	// REQUIRED
	NextMarker *string `xml:"NextMarker"`

	// REQUIRED
	Prefix *string `xml:"Prefix"`

	// REQUIRED
	ServiceEndpoint *string      `xml:"ServiceEndpoint,attr"`
	Containers      []*Container `xml:"Containers>Container"`
	Marker          *string      `xml:"Marker"`
}

func (l *ListContainersResponse) GetMaxResults() (rv int32) {
	if l != nil && l.MaxResults != nil {
		return *l.MaxResults
	}
	return
}

func (l *ListContainersResponse) GetNextMarker() (rv string) {
	if l != nil && l.NextMarker != nil {
		return *l.NextMarker
	}
	return
}

func (l *ListContainersResponse) GetPrefix() (rv string) {
	if l != nil && l.Prefix != nil {
		return *l.Prefix
	}
	return
}

func (l *ListContainersResponse) GetServiceEndpoint() (rv string) {
	if l != nil && l.ServiceEndpoint != nil {
		return *l.ServiceEndpoint
	}
	return
}

func (l *ListContainersResponse) GetContainers() (rv []*Container) {
	if l != nil {
		return l.Containers
	}
	return
}

func (l *ListContainersResponse) GetMarker() (rv string) {
	if l != nil && l.Marker != nil {
		return *l.Marker
	}
	return
}

// Logging - Azure Analytics Logging settings.
type Logging struct {
	// REQUIRED; Indicates whether all delete requests should be logged.
	Delete *bool `xml:"Delete"`

	// REQUIRED; Indicates whether all read requests should be logged.
	Read *bool `xml:"Read"`

	// REQUIRED; the retention policy
	RetentionPolicy *RetentionPolicy `xml:"RetentionPolicy"`

	// REQUIRED; The version of Storage Analytics to configure.
	Version *string `xml:"Version"`

	// REQUIRED; Indicates whether all write requests should be logged.
	Write *bool `xml:"Write"`
}

func (l *Logging) GetDelete() (rv bool) {
	if l != nil && l.Delete != nil {
		return *l.Delete
	}
	return
}

func (l *Logging) GetRead() (rv bool) {
	if l != nil && l.Read != nil {
		return *l.Read
	}
	return
}

func (l *Logging) GetRetentionPolicy() (rv *RetentionPolicy) {
	if l != nil {
		return l.RetentionPolicy
	}
	return
}

func (l *Logging) GetVersion() (rv string) {
	if l != nil && l.Version != nil {
		return *l.Version
	}
	return
}

func (l *Logging) GetWrite() (rv bool) {
	if l != nil && l.Write != nil {
		return *l.Write
	}
	return
}

type Metrics struct {
	// REQUIRED; Indicates whether metrics are enabled for the Blob service.
	Enabled *bool `xml:"Enabled"`

	// Indicates whether metrics should generate summary statistics for called API operations.
	IncludeAPIs *bool `xml:"IncludeAPIs"`

	// the retention policy
	RetentionPolicy *RetentionPolicy `xml:"RetentionPolicy"`

	// The version of Storage Analytics to configure.
	Version *string `xml:"Version"`
}

func (m *Metrics) GetEnabled() (rv bool) {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return
}

func (m *Metrics) GetIncludeAPIs() (rv bool) {
	if m != nil && m.IncludeAPIs != nil {
		return *m.IncludeAPIs
	}
	return
}

func (m *Metrics) GetRetentionPolicy() (rv *RetentionPolicy) {
	if m != nil {
		return m.RetentionPolicy
	}
	return
}

func (m *Metrics) GetVersion() (rv string) {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return
}

type ModelWithByteProperty struct {
	Bytes []byte `xml:"Bytes"`
}

func (m *ModelWithByteProperty) GetBytes() (rv []byte) {
	if m != nil {
		return m.Bytes
	}
	return
}

type ModelWithURLProperty struct {
	URL *string `xml:"Url"`
}

func (m *ModelWithURLProperty) GetURL() (rv string) {
	if m != nil && m.URL != nil {
		return *m.URL
	}
	return
}

// ObjectWithXMsTextProperty - Contans property
type ObjectWithXMsTextProperty struct {
	// Returned value should be 'I am text'
	Content *string `xml:",chardata"`

	// Returned value should be 'english'
	Language *string `xml:"language,attr"`
}

func (o *ObjectWithXMsTextProperty) GetContent() (rv string) {
	if o != nil && o.Content != nil {
		return *o.Content
	}
	return
}

func (o *ObjectWithXMsTextProperty) GetLanguage() (rv string) {
	if o != nil && o.Language != nil {
		return *o.Language
	}
	return
}

// RetentionPolicy - the retention policy
type RetentionPolicy struct {
	// REQUIRED; Indicates whether a retention policy is enabled for the storage service
	Enabled *bool `xml:"Enabled"`

	// Indicates the number of days that metrics or logging or soft-deleted data should be retained. All data older than this
	// value will be deleted
	Days *int32 `xml:"Days"`
}

func (r *RetentionPolicy) GetEnabled() (rv bool) {
	if r != nil && r.Enabled != nil {
		return *r.Enabled
	}
	return
}

func (r *RetentionPolicy) GetDays() (rv int32) {
	if r != nil && r.Days != nil {
		return *r.Days
	}
	return
}

// RootWithRefAndMeta - I am root, and I ref a model WITH meta
type RootWithRefAndMeta struct {
	// XML will use XMLComplexTypeWithMeta
	RefToModel *ComplexTypeWithMeta `xml:"XMLComplexTypeWithMeta"`

	// Something else (just to avoid flattening)
	Something *string `xml:"Something"`
}

func (r *RootWithRefAndMeta) GetRefToModel() (rv *ComplexTypeWithMeta) {
	if r != nil {
		return r.RefToModel
	}
	return
}

func (r *RootWithRefAndMeta) GetSomething() (rv string) {
	if r != nil && r.Something != nil {
		return *r.Something
	}
	return
}

// RootWithRefAndNoMeta - I am root, and I ref a model with no meta
type RootWithRefAndNoMeta struct {
	// XML will use RefToModel
	RefToModel *ComplexTypeNoMeta `xml:"RefToModel"`

	// Something else (just to avoid flattening)
	Something *string `xml:"Something"`
}

func (r *RootWithRefAndNoMeta) GetRefToModel() (rv *ComplexTypeNoMeta) {
	if r != nil {
		return r.RefToModel
	}
	return
}

func (r *RootWithRefAndNoMeta) GetSomething() (rv string) {
	if r != nil && r.Something != nil {
		return *r.Something
	}
	return
}

// SignedIdentifier - signed identifier
type SignedIdentifier struct {
	// REQUIRED; The access policy
	AccessPolicy *AccessPolicy `xml:"AccessPolicy"`

	// REQUIRED; a unique id
	ID *string `xml:"Id"`
}

func (s *SignedIdentifier) GetAccessPolicy() (rv *AccessPolicy) {
	if s != nil {
		return s.AccessPolicy
	}
	return
}

func (s *SignedIdentifier) GetID() (rv string) {
	if s != nil && s.ID != nil {
		return *s.ID
	}
	return
}

// Slide - A slide in a slideshow
type Slide struct {
	Items []*string `xml:"item"`
	Title *string   `xml:"title"`
	Type  *string   `xml:"type,attr"`
}

func (s *Slide) GetItems() (rv []*string) {
	if s != nil {
		return s.Items
	}
	return
}

func (s *Slide) GetTitle() (rv string) {
	if s != nil && s.Title != nil {
		return *s.Title
	}
	return
}

func (s *Slide) GetType() (rv string) {
	if s != nil && s.Type != nil {
		return *s.Type
	}
	return
}

// Slideshow - Data about a slideshow
type Slideshow struct {
	Author *string  `xml:"author,attr"`
	Date   *string  `xml:"date,attr"`
	Slides []*Slide `xml:"slide"`
	Title  *string  `xml:"title,attr"`
}

func (s *Slideshow) GetAuthor() (rv string) {
	if s != nil && s.Author != nil {
		return *s.Author
	}
	return
}

func (s *Slideshow) GetDate() (rv string) {
	if s != nil && s.Date != nil {
		return *s.Date
	}
	return
}

func (s *Slideshow) GetSlides() (rv []*Slide) {
	if s != nil {
		return s.Slides
	}
	return
}

func (s *Slideshow) GetTitle() (rv string) {
	if s != nil && s.Title != nil {
		return *s.Title
	}
	return
}

// StorageServiceProperties - Storage Service Properties.
type StorageServiceProperties struct {
	// The set of CORS rules.
	Cors []*CorsRule `xml:"Cors>CorsRule"`

	// The default version to use for requests to the Blob service if an incoming request's version is not specified. Possible
	// values include version 2008-10-27 and all more recent versions
	DefaultServiceVersion *string `xml:"DefaultServiceVersion"`

	// The Delete Retention Policy for the service
	DeleteRetentionPolicy *RetentionPolicy `xml:"DeleteRetentionPolicy"`

	// A summary of request statistics grouped by API in hourly aggregates for blobs
	HourMetrics *Metrics `xml:"HourMetrics"`

	// Azure Analytics Logging settings
	Logging *Logging `xml:"Logging"`

	// a summary of request statistics grouped by API in minute aggregates for blobs
	MinuteMetrics *Metrics `xml:"MinuteMetrics"`
}

func (s *StorageServiceProperties) GetCors() (rv []*CorsRule) {
	if s != nil {
		return s.Cors
	}
	return
}

func (s *StorageServiceProperties) GetDefaultServiceVersion() (rv string) {
	if s != nil && s.DefaultServiceVersion != nil {
		return *s.DefaultServiceVersion
	}
	return
}

func (s *StorageServiceProperties) GetDeleteRetentionPolicy() (rv *RetentionPolicy) {
	if s != nil {
		return s.DeleteRetentionPolicy
	}
	return
}

func (s *StorageServiceProperties) GetHourMetrics() (rv *Metrics) {
	if s != nil {
		return s.HourMetrics
	}
	return
}

func (s *StorageServiceProperties) GetLogging() (rv *Logging) {
	if s != nil {
		return s.Logging
	}
	return
}

func (s *StorageServiceProperties) GetMinuteMetrics() (rv *Metrics) {
	if s != nil {
		return s.MinuteMetrics
	}
	return
}
